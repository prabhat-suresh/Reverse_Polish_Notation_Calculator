# Reverse_Polish_Notation_Calculator

#### A course assignment taken up to explore programming in Rust and Ocaml.

The aim of this project is to build a **reverse polish notation** calculator for **polynomials** over one variable in
reals that can do *symbolic differentiation*!

Reverse polish notation (RPN) or the postfix notation is a mathematical notation where the operator appears
after the operands. For example, “5 + 3” in postfix is “5 3 +”. This allows a mathematical expression to be
written without the need of using parentheses.

You are given an expression in the RPN form and your task is to evaluate the RPN expression and output
the result as an RPN expression.

### Specifications

The implementation has been specified in stages. You are very strongly recommended to follow these stages.
It is recommended (though not mandatory) that you create test cases for each of the stages. This way, you
can test each stage before proceeding to the next one.

- Stage 1: First, build a calculator that can do integer arithmetic involving operations ˆ, /, *, +,
\- corresponding to the usual operations of exponentiation, division, multiplication, addition and
subtraction.                    
An example is: 2 5 ˆ 10 + should
output 42 !

- Stage 2: Extend stage 1 to include operations over real numbers.
Allow precision of 5 digits after the decimal point.
- Stage 3. Extend stage 2 to include operations involving a symbolic variable x.
For instance, arithmetic involving variables must return the correct expression. For example
1 x + x 1 + + should return 2 x 2 * +.  
Please refer to the grammar below to decide whether an expression in RPN
form is valid or not. While testing this stage, you may assume that / does not appear in the input and
exponent of any variable x is non-negative.
- Stage 4: Extend stage 3 to include a new operator d that differentiates its argument with respect to x.
For example x 2 ˆ d should output x 2 *. The d operator has the highest precedence among
the rest of operators. While testing this stage, you may assume that / does not appear in the input and
exponent of any variable x is non-negative.
- Stage 5: Reimplement stage 4 (as well as stage 3) to (1) allow division / operation in the expression
and (2) allow variable x to have negative exponent.
That is, you may get expressions of the form x -2 ˆ 1 + x /. While testing this stage, you may
assume that d (differentiation) does not appear in the input.
- Stage 6: Reimplement stage 5 to allow differentiation on rationals of polynomials of x.
That is, x -2 ˆ1 + x / d should output -3 x -4 ˆ * -1 x -2 ˆ * +. Note: the denom-
inator part can be an arbitrary polynomial in x and need not always be x.

### Validity of expressions
A well formed RPN expression is the one generated by the following grammar rules (with E as the starting
non-terminal).

E -> E E + | E E - | E E * | E E / | E d | E n ^

E -> x | n | n.PPPPP

P -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

Here n is a signed integer of 32 bits.

- Your program must output “Parse error” if the input expression is not a string generated by the above
grammar.
- While outputing terms involving powers of variable x, the terms should appear in the increasing order of
degree. For example, if your final expression is (x2 + x + 1)/(x + 1), it should be printed (in RPN as) 1 x +
x 2 ˆ + 1 x + /
- A successful run of the program should terminate with a return 0. If the result involves division by zero,
then program should output the string “NAN” (Not a number). 
- On any error, the program should gracefully exit and return 1 and should not crash (messages like stack overflow, memory overflow or segmentation fault
while running the program is not acceptable).

#### Choice of Programming language
- You are allowed to use only low level languages like C, C++ or Rust.
- You are only allowed to use the standard libraries that comes with these languages. Since your code
will be tested against large test cases, language like Python will be inadequate.
- Your code will be benchmarked against a set of test cases.
- Specification of the test will be given in due course.

Here are the contents of a sample test file test.txt. Each of the test expressions will be provided in a new
line. Your program should process the input line-by-line till it sees “EOF” appearing in a newline.

41 x x 2 ^ + 1 x +  
x 2 ^ 1.00001 + d  
3 2 3 - 1 + /  
EOF

Output should be:

Parse error  
x 2 *  
NAN